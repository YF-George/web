<script lang="ts">
	import { onMount } from 'svelte';
	import SpreadsheetCell from '$lib/components/SpreadsheetCell.svelte';

	interface Edit {
		id: string;
		formId: string;
		displayName: string;
		action: {
			type: string;
			row: number;
			col: number;
			value: string;
			timestamp?: number;
			formatting?: {
				textColor?: string;
				bgColor?: string;
				fontWeight?: string;
				fontStyle?: string;
				textDecoration?: string;
				fontSize?: string;
				textAlign?: string;
			};
		};
		created_at: string;
	}

	interface CellData {
		value: string;
		lastEditor?: string;
		lastEditTime?: string;
		// Formatting properties
		textColor?: string;
		bgColor?: string;
		fontWeight?: string;
		fontStyle?: string;
		textDecoration?: string;
		fontSize?: string;
		textAlign?: string;
	}

	let { params }: { params: { id: string } } = $props();

	let ROWS = $state(20);
	let COLS = $state(10);
	let COL_LABELS = $derived(
		Array.from({ length: COLS }, (_, i) => String.fromCharCode(65 + (i % 26)))
	);

	let displayName = $state('');
	let autoGeneratedName = $state('');
	let useAutoName = $state(false);
	let status = $state('');
	let loading = $state(false);
	let edits = $state<Edit[]>([]);
	let loadingHistory = $state(false);

	// Spreadsheet state - initialize dynamically
	let cells = $state<CellData[][]>([]);

	function initializeCells() {
		cells = Array(ROWS)
			.fill(null)
			.map(() =>
				Array(COLS)
					.fill(null)
					.map(() => ({ value: '' }))
			);
	}
	let editingCell = $state({ row: -1, col: -1 });
	let selectedCell = $state({ row: -1, col: -1 });
	let onlineUsers = $state<Set<string>>(new Set());

	// Clipboard and undo/redo
	let clipboard = $state<CellData | null>(null);
	let history = $state<CellData[][][]>([]);
	let historyIndex = $state(-1);

	// Current formatting toolbar values
	let currentTextColor = $state('#000000');
	let currentBgColor = $state('#ffffff');
	let currentFontSize = $state('14');

	function generateAutoName() {
		const adjectives = [
			'Explorer',
			'Creator',
			'Thinker',
			'Builder',
			'Artist',
			'Scholar',
			'Voyager',
			'Pioneer'
		];
		const numbers = Math.floor(Math.random() * 1000);
		const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
		return `${adj}_${numbers}`;
	}

	function initializePseudonym() {
		const saved = localStorage.getItem(`forms-${params.id}-name`);
		const savedUseAuto = localStorage.getItem(`forms-${params.id}-useAuto`);

		if (saved) {
			displayName = saved;
			useAutoName = savedUseAuto === 'true';
		} else {
			autoGeneratedName = generateAutoName();
			useAutoName = true;
		}
	}

	function savePseudonym() {
		const name = useAutoName ? autoGeneratedName : displayName;
		localStorage.setItem(`forms-${params.id}-name`, name);
		localStorage.setItem(`forms-${params.id}-useAuto`, String(useAutoName));
	}

	function toggleAutoName() {
		useAutoName = !useAutoName;
		if (useAutoName) {
			autoGeneratedName = generateAutoName();
		}
		savePseudonym();
		status = useAutoName ? 'ğŸ‰ å·²åˆ‡æ›ä¾†è‡ªå‹•æš±ç¨±' : 'âœï¸ æ—¢æ˜¯è‡ªè¨‚åç¨±';
		setTimeout(() => {
			status = '';
		}, 2000);
	}

	function addRow() {
		if (ROWS < 1000) {
			const newRow = Array(COLS)
				.fill(null)
				.map(() => ({ value: '' }));
			cells = [...cells, newRow];
			ROWS++;
			status = `âœ… å·²æ–°å¢ä¸€è¡Œï¼ˆå…± ${ROWS} è¡Œï¼‰`;
			setTimeout(() => {
				status = '';
			}, 2000);
		}
	}

	function removeRow() {
		if (ROWS > 1) {
			cells = cells.slice(0, -1);
			ROWS--;
			// Reset selected cell if it's in the deleted row
			if (selectedCell.row >= ROWS) {
				selectedCell = { row: -1, col: -1 };
			}
			status = `âœ… å·²ç§»é™¤æœ€å¾Œä¸€è¡Œï¼ˆå…± ${ROWS} è¡Œï¼‰`;
			setTimeout(() => {
				status = '';
			}, 2000);
		}
	}

	function addCol() {
		if (COLS < 100) {
			cells = cells.map((row) => [...row, { value: '' }]);
			COLS++;
			status = `âœ… å·²æ–°å¢ä¸€æ¬„ï¼ˆå…± ${COLS} æ¬„ï¼‰`;
			setTimeout(() => {
				status = '';
			}, 2000);
		}
	}

	function removeCol() {
		if (COLS > 1) {
			cells = cells.map((row) => row.slice(0, -1));
			COLS--;
			// Reset selected cell if it's in the deleted column
			if (selectedCell.col >= COLS) {
				selectedCell = { row: -1, col: -1 };
			}
			status = `âœ… å·²ç§»é™¤æœ€å¾Œä¸€æ¬„ï¼ˆå…± ${COLS} æ¬„ï¼‰`;
			setTimeout(() => {
				status = '';
			}, 2000);
		}
	}

	function getCellAddress(row: number, col: number): string {
		return `${COL_LABELS[col]}${row + 1}`;
	}

	async function loadHistory() {
		loadingHistory = true;
		try {
			const res = await fetch(`/api/edits?formId=${encodeURIComponent(params.id)}`);
			if (res.ok) {
				const data = await res.json();
				edits = data.edits || [];

				// Reconstruct spreadsheet from edit history
				const newCells: CellData[][] = Array(ROWS)
					.fill(null)
					.map(() =>
						Array(COLS)
							.fill(null)
							.map(() => ({ value: '' }))
					);

				const userSet = new Set<string>();

				edits.forEach((edit) => {
					if (
						edit.action.type === 'cell-edit' &&
						edit.action.row !== undefined &&
						edit.action.col !== undefined
					) {
						const { row, col, value, formatting } = edit.action;
						if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
							newCells[row][col] = {
								value: value || '',
								lastEditor: edit.displayName,
								lastEditTime: edit.created_at,
								// Load formatting if available
								...(formatting && {
									textColor: formatting.textColor,
									bgColor: formatting.bgColor,
									fontWeight: formatting.fontWeight,
									fontStyle: formatting.fontStyle,
									textDecoration: formatting.textDecoration,
									fontSize: formatting.fontSize,
									textAlign: formatting.textAlign
								})
							};
							userSet.add(edit.displayName);
						}
					}
				});

				cells = newCells;
				onlineUsers = userSet;
			}
		} catch (e) {
			console.error('Failed to load history:', e);
		} finally {
			loadingHistory = false;
		}
	}

	async function saveCell(row: number, col: number, value: string) {
		// Format-only changes don't require a name
		const cell = cells[row][col];
		const hasFormatting =
			cell.textColor ||
			cell.bgColor ||
			cell.fontWeight ||
			cell.fontStyle ||
			cell.textDecoration ||
			cell.fontSize ||
			cell.textAlign;
		const actualName = useAutoName ? autoGeneratedName : displayName.trim();

		// Only require displayName for content changes
		if (!actualName && !hasFormatting) {
			status = 'âŒ è«‹å…ˆè¨­å®šé¡¯ç¤ºåç¨±æˆ–ä½¿ç”¨è‡ªå‹•æš´ç¨±';
			setTimeout(() => {
				status = '';
			}, 3000);
			return;
		}

		loading = true;
		status = 'ğŸ’¾ å„²å­˜ä¸­...';

		try {
			const res = await fetch('/api/edits', {
				method: 'POST',
				headers: { 'content-type': 'application/json' },
				body: JSON.stringify({
					formId: params.id,
					displayName: useAutoName ? autoGeneratedName : displayName.trim() || 'Anonymous',
					pseudonym: `user-${Date.now()}-${Math.random().toString(36).slice(2)}`,
					action: {
						type: 'cell-edit',
						row,
						col,
						value,
						cellAddress: getCellAddress(row, col),
						timestamp: Date.now(),
						// Include formatting data
						formatting: {
							textColor: cell.textColor,
							bgColor: cell.bgColor,
							fontWeight: cell.fontWeight,
							fontStyle: cell.fontStyle,
							textDecoration: cell.textDecoration,
							fontSize: cell.fontSize,
							textAlign: cell.textAlign
						}
					}
				})
			});

			if (!res.ok) {
				const j = await res.json().catch(() => ({}));
				const errorMsg = j?.error || res.status;
				if (errorMsg === 'invalid displayName') {
					status = 'âŒ åç¨±æ ¼å¼ä¸æ­£ç¢ºï¼ˆåƒ…å…è¨±æ–‡å­—ã€æ•¸å­—ã€ç©ºç™½ã€_ å’Œ -ï¼‰';
				} else {
					status = 'âŒ éŒ¯èª¤: ' + errorMsg;
				}
				return;
			}

			// Update local state (preserve formatting)
			cells[row][col] = {
				...cells[row][col],
				value,
				lastEditor: displayName.trim(),
				lastEditTime: new Date().toISOString()
			};

			status = 'âœ… å·²å„²å­˜';
			setTimeout(() => {
				status = '';
			}, 2000);
			setTimeout(() => loadHistory(), 500);
		} catch (e) {
			status = 'âŒ å¤±æ•—: ' + String(e);
		} finally {
			loading = false;
		}
	}

	function handleEdit(row: number, col: number) {
		editingCell = { row, col };
		selectedCell = { row, col };
		// Don't change toolbar values - keep user's current selection
	}

	function handleSelect(row: number, col: number) {
		selectedCell = { row, col };
		// Don't change toolbar values - keep user's current selection
	}

	function loadCellFormat() {
		// Load the current cell's format into toolbar
		if (selectedCell.row >= 0 && selectedCell.col >= 0) {
			const cell = cells[selectedCell.row][selectedCell.col];
			currentTextColor = cell.textColor || '#000000';
			currentBgColor = cell.bgColor || '#ffffff';
			const sizeMatch = cell.fontSize?.match(/\d+/);
			currentFontSize = sizeMatch ? sizeMatch[0] : '14';
			status = 'ğŸ“‹ å·²è¼‰å…¥å„²å­˜æ ¼æ ¼å¼';
			setTimeout(() => {
				status = '';
			}, 1500);
		}
	}

	function saveToHistory() {
		history = history.slice(0, historyIndex + 1);
		history.push(JSON.parse(JSON.stringify(cells)));
		historyIndex++;
		if (history.length > 50) {
			history.shift();
			historyIndex--;
		}
	}

	function undo() {
		if (historyIndex > 0) {
			historyIndex--;
			cells = JSON.parse(JSON.stringify(history[historyIndex]));
		}
	}

	function redo() {
		if (historyIndex < history.length - 1) {
			historyIndex++;
			cells = JSON.parse(JSON.stringify(history[historyIndex]));
		}
	}

	function copyCell() {
		if (selectedCell.row >= 0 && selectedCell.col >= 0) {
			clipboard = JSON.parse(JSON.stringify(cells[selectedCell.row][selectedCell.col]));
			status = 'ğŸ“‹ å·²è¤‡è£½';
			setTimeout(() => {
				status = '';
			}, 1500);
		}
	}

	function cutCell() {
		if (selectedCell.row >= 0 && selectedCell.col >= 0) {
			clipboard = JSON.parse(JSON.stringify(cells[selectedCell.row][selectedCell.col]));
			saveToHistory();
			cells[selectedCell.row][selectedCell.col] = { value: '' };
			saveCell(selectedCell.row, selectedCell.col, '');
			status = 'âœ‚ï¸ å·²å‰ªä¸‹';
			setTimeout(() => {
				status = '';
			}, 1500);
		}
	}

	function pasteCell() {
		if (clipboard && selectedCell.row >= 0 && selectedCell.col >= 0) {
			saveToHistory();
			cells[selectedCell.row][selectedCell.col] = JSON.parse(JSON.stringify(clipboard));
			saveCell(selectedCell.row, selectedCell.col, clipboard.value);
			status = 'ğŸ“Œ å·²è²¼ä¸Š';
			setTimeout(() => {
				status = '';
			}, 1500);
		}
	}

	function deleteCell() {
		if (selectedCell.row >= 0 && selectedCell.col >= 0) {
			saveToHistory();
			cells[selectedCell.row][selectedCell.col] = { value: '' };
			saveCell(selectedCell.row, selectedCell.col, '');
		}
	}

	function applyFormatting(property: keyof CellData, value: string | boolean | number) {
		if (selectedCell.row >= 0 && selectedCell.col >= 0) {
			saveToHistory();
			cells[selectedCell.row][selectedCell.col] = {
				...cells[selectedCell.row][selectedCell.col],
				[property]: value
			};
			// Format changes are local only - will be saved when content is edited
			status = 'ğŸ¨ æ ¼å¼å·²å¥—ç”¨ï¼ˆæœ¬åœ°ï¼‰';
			setTimeout(() => {
				status = '';
			}, 1500);
		}
	}

	function toggleBold() {
		if (selectedCell.row >= 0 && selectedCell.col >= 0) {
			const cell = cells[selectedCell.row][selectedCell.col];
			applyFormatting('fontWeight', cell.fontWeight === 'bold' ? 'normal' : 'bold');
		}
	}

	function toggleItalic() {
		if (selectedCell.row >= 0 && selectedCell.col >= 0) {
			const cell = cells[selectedCell.row][selectedCell.col];
			applyFormatting('fontStyle', cell.fontStyle === 'italic' ? 'normal' : 'italic');
		}
	}

	function toggleUnderline() {
		if (selectedCell.row >= 0 && selectedCell.col >= 0) {
			const cell = cells[selectedCell.row][selectedCell.col];
			applyFormatting('textDecoration', cell.textDecoration === 'underline' ? 'none' : 'underline');
		}
	}

	function handleKeydown(e: KeyboardEvent) {
		if (editingCell.row >= 0) return; // Don't handle shortcuts while editing

		const { row, col } = selectedCell;
		if (row < 0 || col < 0) return;

		// Ctrl/Cmd shortcuts
		if (e.ctrlKey || e.metaKey) {
			switch (e.key.toLowerCase()) {
				case 'c':
					e.preventDefault();
					copyCell();
					break;
				case 'x':
					e.preventDefault();
					cutCell();
					break;
				case 'v':
					e.preventDefault();
					pasteCell();
					break;
				case 'z':
					e.preventDefault();
					undo();
					break;
				case 'y':
					e.preventDefault();
					redo();
					break;
				case 'b':
					e.preventDefault();
					toggleBold();
					break;
				case 'i':
					e.preventDefault();
					toggleItalic();
					break;
				case 'u':
					e.preventDefault();
					toggleUnderline();
					break;
			}
			return;
		}

		// Arrow key navigation
		let newRow = row;
		let newCol = col;

		switch (e.key) {
			case 'ArrowUp':
				e.preventDefault();
				newRow = Math.max(0, row - 1);
				break;
			case 'ArrowDown':
				e.preventDefault();
				newRow = Math.min(ROWS - 1, row + 1);
				break;
			case 'ArrowLeft':
				e.preventDefault();
				newCol = Math.max(0, col - 1);
				break;
			case 'ArrowRight':
				e.preventDefault();
				newCol = Math.min(COLS - 1, col + 1);
				break;
			case 'Tab':
				e.preventDefault();
				newCol = col + 1;
				if (newCol >= COLS) {
					newCol = 0;
					newRow = Math.min(ROWS - 1, row + 1);
				}
				break;
			case 'Enter':
				e.preventDefault();
				handleEdit(row, col);
				return;
			case 'Delete':
				e.preventDefault();
				deleteCell();
				return;
			default:
				return;
		}

		handleSelect(newRow, newCol);
	}

	// Removed unused formatDate function

	onMount(() => {
		initializeCells();
		initializePseudonym();
		loadHistory();
		saveToHistory(); // Initial state
		const interval = setInterval(loadHistory, 10000); // Refresh every 10s

		// Add global keyboard listener
		window.addEventListener('keydown', handleKeydown);

		return () => {
			clearInterval(interval);
			window.removeEventListener('keydown', handleKeydown);
		};
	});
</script>

<svelte:head>
	<title>åŒ¿åå”ä½œè©¦ç®—è¡¨</title>
</svelte:head>

<div class="container">
	<header>
		<div class="header-content">
			<h1>ğŸ“Š åŒ¿åå”ä½œè©¦ç®—è¡¨</h1>
			<div class="header-actions">
				<a data-sveltekit-preload-data href="/history" class="btn-history">ğŸ“œ ç·¨è¼¯è¨˜éŒ„</a>
				<button
					class="btn-refresh"
					onclick={loadHistory}
					disabled={loadingHistory}
					title="é‡æ–°æ•´ç†"
				>
					{loadingHistory ? 'â³' : 'ğŸ”„'}
				</button>
			</div>
		</div>
		<p class="description">é¡ Excel ä»‹é¢ï¼Œå³æ™‚å”ä½œï¼Œè¼¸å…¥åç¨±å¾Œé›™æ“Šå„²å­˜æ ¼ç·¨è¼¯</p>
	</header>

	<div class="toolbar">
		<div class="user-info">
			{#if useAutoName}
				<div class="pseudonym-display">
					ğŸ­ {autoGeneratedName}
					<button class="toggle-name-btn" onclick={toggleAutoName} title="åˆ‡æ›åˆ°è‡ªè¨‚åç¨±">
						âœï¸
					</button>
				</div>
			{:else}
				<input
					bind:value={displayName}
					placeholder="ä½ çš„åç¨±"
					class="name-input"
					disabled={loading}
					onchange={savePseudonym}
				/>
				<button class="toggle-name-btn" onclick={toggleAutoName} title="åˆ‡æ›åˆ°è‡ªå‹•æš±ç¨±">
					ğŸ‰
				</button>
			{/if}
			<span class="online-count" title="æœ€è¿‘ç·¨è¼¯éçš„ä½¿ç”¨è€…">
				ğŸ‘¥ {onlineUsers.size} ä½å”ä½œè€…
			</span>
		</div>
		{#if status}
			<div class="status" class:error={status.includes('âŒ')} class:success={status.includes('âœ…')}>
				{status}
			</div>
		{/if}
	</div>

	<!-- Row/Column Control Toolbar -->
	<div class="control-toolbar">
		<div class="control-group">
			<span class="size-display">ğŸ“ {ROWS} è¡Œ Ã— {COLS} æ¬„</span>
		</div>
		<div class="control-group">
			<button class="control-btn" onclick={addRow} title="æ–°å¢ä¸€è¡Œ">â• è¡Œ</button>
			<button class="control-btn" onclick={removeRow} disabled={ROWS <= 1} title="ç§»é™¤æœ€å¾Œä¸€è¡Œ"
				>â– è¡Œ</button
			>
			<button class="control-btn" onclick={addCol} title="æ–°å¢ä¸€æ¬„">â• æ¬„</button>
			<button class="control-btn" onclick={removeCol} disabled={COLS <= 1} title="ç§»é™¤æœ€å¾Œä¸€æ¬„"
				>â– æ¬„</button
			>
		</div>
	</div>

	<!-- Formatting Toolbar -->
	<div class="format-toolbar">
		<div class="format-group">
			<button
				class="format-btn"
				onclick={loadCellFormat}
				disabled={selectedCell.row < 0}
				title="è¼‰å…¥å„²å­˜æ ¼æ ¼å¼åˆ°å·¥å…·åˆ—"
				style="font-size: 1.1rem;"
			>
				ğŸ“‹
			</button>
		</div>

		<div class="format-group">
			<button
				class="format-btn"
				class:active={selectedCell.row >= 0 &&
					cells[selectedCell.row]?.[selectedCell.col]?.fontWeight === 'bold'}
				onclick={toggleBold}
				title="ç²—é«” (Ctrl+B)"
			>
				<strong>B</strong>
			</button>
			<button
				class="format-btn"
				class:active={selectedCell.row >= 0 &&
					cells[selectedCell.row]?.[selectedCell.col]?.fontStyle === 'italic'}
				onclick={toggleItalic}
				title="æ–œé«” (Ctrl+I)"
			>
				<em>I</em>
			</button>
			<button
				class="format-btn"
				class:active={selectedCell.row >= 0 &&
					cells[selectedCell.row]?.[selectedCell.col]?.textDecoration === 'underline'}
				onclick={toggleUnderline}
				title="åº•ç·š (Ctrl+U)"
			>
				<u>U</u>
			</button>
		</div>

		<div class="format-group">
			<label class="color-picker-label" title="æ–‡å­—é¡è‰²">
				<span>A</span>
				<input
					type="color"
					bind:value={currentTextColor}
					onchange={() => applyFormatting('textColor', currentTextColor)}
					class="color-input"
				/>
			</label>
			<label class="color-picker-label" title="èƒŒæ™¯é¡è‰²">
				<span style="background: {currentBgColor}; padding: 2px 6px; border-radius: 3px;">â–ˆ</span>
				<input
					type="color"
					bind:value={currentBgColor}
					onchange={() => applyFormatting('bgColor', currentBgColor)}
					class="color-input"
				/>
			</label>
		</div>

		<div class="format-group">
			<select
				bind:value={currentFontSize}
				onchange={() => applyFormatting('fontSize', currentFontSize + 'px')}
				class="font-size-select"
				title="å­—é«”å¤§å°"
			>
				<option value="10">10</option>
				<option value="12">12</option>
				<option value="14">14</option>
				<option value="16">16</option>
				<option value="18">18</option>
				<option value="20">20</option>
				<option value="24">24</option>
			</select>
		</div>

		<div class="format-group">
			<button
				class="format-btn"
				class:active={selectedCell.row >= 0 &&
					cells[selectedCell.row]?.[selectedCell.col]?.textAlign === 'left'}
				onclick={() => applyFormatting('textAlign', 'left')}
				title="é å·¦å°é½Š"
			>
				â‰¡
			</button>
			<button
				class="format-btn"
				class:active={selectedCell.row >= 0 &&
					cells[selectedCell.row]?.[selectedCell.col]?.textAlign === 'center'}
				onclick={() => applyFormatting('textAlign', 'center')}
				title="ç½®ä¸­å°é½Š"
			>
				â‰£
			</button>
			<button
				class="format-btn"
				class:active={selectedCell.row >= 0 &&
					cells[selectedCell.row]?.[selectedCell.col]?.textAlign === 'right'}
				onclick={() => applyFormatting('textAlign', 'right')}
				title="é å³å°é½Š"
			>
				â‰¡
			</button>
		</div>

		<div class="format-group">
			<button class="format-btn" onclick={undo} disabled={historyIndex <= 0} title="å¾©åŸ (Ctrl+Z)">
				â†¶
			</button>
			<button
				class="format-btn"
				onclick={redo}
				disabled={historyIndex >= history.length - 1}
				title="é‡åš (Ctrl+Y)"
			>
				â†·
			</button>
		</div>

		<div class="format-group">
			<button
				class="format-btn"
				onclick={copyCell}
				disabled={selectedCell.row < 0}
				title="è¤‡è£½ (Ctrl+C)"
			>
				ğŸ“‹
			</button>
			<button
				class="format-btn"
				onclick={cutCell}
				disabled={selectedCell.row < 0}
				title="å‰ªä¸‹ (Ctrl+X)"
			>
				âœ‚ï¸
			</button>
			<button
				class="format-btn"
				onclick={pasteCell}
				disabled={!clipboard || selectedCell.row < 0}
				title="è²¼ä¸Š (Ctrl+V)"
			>
				ğŸ“Œ
			</button>
			<button
				class="format-btn"
				onclick={deleteCell}
				disabled={selectedCell.row < 0}
				title="åˆªé™¤ (Delete)"
			>
				ğŸ—‘ï¸
			</button>
		</div>
	</div>

	<div class="spreadsheet-container">
		<div class="spreadsheet">
			<!-- Column headers -->
			<div class="row header-row">
				<div class="cell corner-cell">#</div>
				{#each COL_LABELS as label (label)}
					<div class="cell header-cell">{label}</div>
				{/each}
			</div>

			<!-- Data rows -->
			{#each cells as row, rowIndex (rowIndex)}
				<div class="row">
					<div class="cell row-header">{rowIndex + 1}</div>
					{#each row as cell, colIndex (colIndex)}
						<SpreadsheetCell
							value={cell.value}
							{rowIndex}
							{colIndex}
							isEditing={editingCell.row === rowIndex && editingCell.col === colIndex}
							isSelected={selectedCell.row === rowIndex && selectedCell.col === colIndex}
							onEdit={handleEdit}
							onSelect={handleSelect}
							onSave={saveCell}
							textColor={cell.textColor}
							bgColor={cell.bgColor}
							fontWeight={cell.fontWeight}
							fontStyle={cell.fontStyle}
							textDecoration={cell.textDecoration}
							fontSize={cell.fontSize}
							textAlign={cell.textAlign}
						/>
					{/each}
				</div>
			{/each}
		</div>
	</div>
</div>

<style>
	:global(body) {
		margin: 0;
		font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
		background: #f5f5f5;
		color: #333;
	}

	.container {
		max-width: 1400px;
		margin: 0 auto;
		padding: 1rem;
	}

	header {
		background: white;
		padding: 1.5rem;
		border-radius: 8px;
		box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
		margin-bottom: 1rem;
	}

	.header-content {
		display: flex;
		justify-content: space-between;
		align-items: center;
		margin-bottom: 0.5rem;
	}

	h1 {
		margin: 0;
		font-size: 1.75rem;
		color: #1a1a1a;
	}

	.description {
		margin: 0;
		color: #666;
		font-size: 0.9rem;
	}

	.header-actions {
		display: flex;
		gap: 0.5rem;
		align-items: center;
	}

	.btn-history {
		padding: 0.6rem 1.25rem;
		background: #4a90e2;
		color: white;
		text-decoration: none;
		border-radius: 8px;
		font-weight: 600;
		font-size: 0.9rem;
		transition: background 0.2s;
		display: inline-block;
	}

	.btn-history:hover {
		background: #357abd;
	}

	.toolbar {
		background: white;
		padding: 1rem;
		border-radius: 8px;
		box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
		margin-bottom: 1rem;
		display: flex;
		justify-content: space-between;
		align-items: center;
		flex-wrap: wrap;
		gap: 0.75rem;
	}

	.control-toolbar {
		background: white;
		padding: 0.75rem;
		border-radius: 8px;
		box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
		margin-bottom: 1rem;
		display: flex;
		gap: 1rem;
		align-items: center;
		flex-wrap: wrap;
	}

	.control-group {
		display: flex;
		gap: 0.5rem;
		align-items: center;
	}

	.size-display {
		font-weight: 600;
		font-size: 0.95rem;
		color: #333;
		padding: 0.4rem 0.8rem;
		background: #f5f5f5;
		border-radius: 4px;
	}

	.control-btn {
		padding: 0.5rem 0.75rem;
		border: 1px solid #ddd;
		background: white;
		border-radius: 4px;
		cursor: pointer;
		font-size: 0.85rem;
		font-weight: 600;
		transition: all 0.2s;
		display: inline-flex;
		align-items: center;
		gap: 0.25rem;
	}

	.control-btn:hover:not(:disabled) {
		background: #f0f7ff;
		border-color: #4a90e2;
		color: #4a90e2;
	}

	.control-btn:disabled {
		opacity: 0.4;
		cursor: not-allowed;
	}

	.format-toolbar {
		background: white;
		padding: 0.75rem;
		border-radius: 8px;
		box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
		margin-bottom: 1rem;
		display: flex;
		flex-wrap: wrap;
		gap: 0.5rem;
		align-items: center;
	}

	.format-group {
		display: flex;
		gap: 0.25rem;
		align-items: center;
		padding: 0 0.5rem;
		border-right: 1px solid #e0e0e0;
	}

	.format-group:last-child {
		border-right: none;
	}

	.format-btn {
		padding: 0.4rem 0.6rem;
		border: 1px solid #ddd;
		background: white;
		border-radius: 4px;
		cursor: pointer;
		font-size: 0.9rem;
		font-weight: 600;
		transition: all 0.2s;
		min-width: 32px;
		height: 32px;
		display: flex;
		align-items: center;
		justify-content: center;
	}

	.format-btn:hover:not(:disabled) {
		background: #f5f5f5;
		border-color: #4a90e2;
	}

	.format-btn.active {
		background: #4a90e2;
		color: white;
		border-color: #4a90e2;
	}

	.format-btn:disabled {
		opacity: 0.4;
		cursor: not-allowed;
	}

	.color-picker-label {
		display: flex;
		align-items: center;
		gap: 0.25rem;
		cursor: pointer;
		padding: 0.4rem 0.6rem;
		border: 1px solid #ddd;
		background: white;
		border-radius: 4px;
		transition: all 0.2s;
		height: 32px;
	}

	.color-picker-label:hover {
		background: #f5f5f5;
		border-color: #4a90e2;
	}

	.color-input {
		width: 0;
		height: 0;
		opacity: 0;
		position: absolute;
	}

	.font-size-select {
		padding: 0.4rem 0.6rem;
		border: 1px solid #ddd;
		border-radius: 4px;
		font-size: 0.9rem;
		background: white;
		cursor: pointer;
		height: 32px;
	}

	.font-size-select:disabled {
		opacity: 0.4;
		cursor: not-allowed;
	}

	.user-info {
		display: flex;
		gap: 0.75rem;
		align-items: center;
		flex-wrap: wrap;
	}

	.name-input {
		padding: 0.5rem 0.75rem;
		border: 1px solid #ddd;
		border-radius: 6px;
		font-size: 0.9rem;
		width: 150px;
	}

	.pseudonym-display {
		padding: 0.5rem 0.75rem;
		background: #f0f7ff;
		border: 1px solid #4a90e2;
		border-radius: 6px;
		font-size: 0.9rem;
		font-weight: 500;
		color: #1976d2;
		display: flex;
		gap: 0.5rem;
		align-items: center;
	}

	.toggle-name-btn {
		padding: 0.25rem 0.5rem;
		border: none;
		background: transparent;
		cursor: pointer;
		font-size: 0.9rem;
		border-radius: 4px;
		transition: background 0.2s;
		display: inline-flex;
		align-items: center;
	}

	.toggle-name-btn:hover {
		background: rgba(74, 144, 226, 0.1);
	}

	.online-count {
		padding: 0.5rem 0.75rem;
		background: #e3f2fd;
		color: #1976d2;
		border-radius: 6px;
		font-size: 0.85rem;
		font-weight: 500;
	}

	.btn-refresh {
		padding: 0.5rem 0.75rem;
		border: none;
		background: #f0f0f0;
		border-radius: 6px;
		font-size: 1.2rem;
		cursor: pointer;
		transition: background 0.2s;
	}

	.btn-refresh:hover:not(:disabled) {
		background: #e0e0e0;
	}

	.btn-refresh:disabled {
		opacity: 0.5;
		cursor: not-allowed;
	}

	.status {
		padding: 0.5rem 1rem;
		border-radius: 6px;
		font-size: 0.85rem;
		font-weight: 500;
	}

	.status.success {
		background: #d4edda;
		color: #155724;
	}

	.status.error {
		background: #f8d7da;
		color: #721c24;
	}

	.spreadsheet-container {
		background: white;
		border-radius: 8px;
		box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
		overflow: auto;
		margin-bottom: 1rem;
	}

	.spreadsheet {
		display: table;
		border-collapse: collapse;
		min-width: 100%;
	}

	.row {
		display: table-row;
	}

	.header-row {
		position: sticky;
		top: 0;
		z-index: 20;
		background: #f5f5f5;
	}

	.cell {
		display: table-cell;
		border: 1px solid #e0e0e0;
		min-width: 100px;
		max-width: 200px;
	}

	.corner-cell,
	.row-header,
	.header-cell {
		background: #f5f5f5;
		font-weight: 600;
		text-align: center;
		padding: 0.5rem;
		position: sticky;
		left: 0;
		z-index: 10;
		user-select: none;
		-webkit-user-select: none;
		-moz-user-select: none;
		-ms-user-select: none;
	}

	.corner-cell {
		min-width: 50px;
		max-width: 50px;
		z-index: 30;
	}

	.row-header {
		min-width: 50px;
		max-width: 50px;
		left: 0;
		z-index: 10;
	}

	@media (max-width: 768px) {
		.toolbar {
			flex-direction: column;
			align-items: stretch;
		}

		.user-info {
			flex-direction: column;
		}

		.name-input {
			width: 100%;
		}
	}
</style>
